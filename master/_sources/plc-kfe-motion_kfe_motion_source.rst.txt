

DUTs
----


E_PositionState
^^^^^^^^^^^^^^^

::

    TYPE E_PositionState :
    (
    RETRACTED    := 0,
    INSERTED    := 1,
    MOVING    := 2,
    INVALID :=3
    );
    END_TYPE


ST_MPA
^^^^^^

::

    TYPE ST_MPA :
    STRUCT
    //    i_xInsertLS AT %I*: BOOL;
    //    i_xRetractLS AT %I*: BOOL;
    //    _xInsertSW : BOOL;
    //    _xRetractSW : BOOL;
    //    q_xInsertDO AT %Q*: BOOL;
    //    q_xRetractDO AT %Q*: BOOL;
    //    eState : DUT_PneumaticActuator_Position;

        //Readbacks
        {attribute 'pytmc' := '
        pv: IN
        io: i
        '}
        i_bInLS    :    BOOL;
        {attribute 'pytmc' := '
        pv: OUT
        io: i
        '}
        i_bOutLS    :    BOOL;

        //Controls
        {attribute 'pytmc' := '
        pv: INSERT_DO
        io: i
        '}
        q_bRetract    :    BOOL;
        {attribute 'pytmc' := '
        pv: RETRACT_DO
        io: i
        '}
        q_bInsert    :    BOOL;

        //Logic and supervisory
        {attribute 'pytmc' := '
        pv: ILKOK
        io: i
        '}
        bILK_OK: BOOL;
        {attribute 'pytmc' := '
        pv: INSERT_OK
        io: i
        '}
        bInsertOK    :    BOOL;
        {attribute 'pytmc' := '
        pv: RETRACT_OK
        io: i
        '}
        bRetractOK    :    BOOL;
        {attribute 'pytmc' := '
        pv: IN_CMD
        io: io
        '}

        bInsert_SW        :    BOOL;
        {attribute 'pytmc' := '
        pv: OUT_CMD
        io: io
        '}
        bRetract_SW    :    BOOL;
        {attribute 'pytmc' := '
        pv: ERROR
        io: io
        '}
        bErrorPresent : BOOL;
        {attribute 'pytmc' := '
        pv: POS_STATE
        type: mbbi
        field: ZRST RETRACTED
        field: ONST INSERTED
        field: TWST MOVING
        field: THST INVALID
        io: i
        '}

        eState    :    E_PositionState := INVALID;


    END_STRUCT
    END_TYPE


GVLs
----


GVL
^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
        {attribute 'pytmc' := 'pv: PLC:KFE:MOTION:ARB'}
        fbArbiter: FB_Arbiter(1);
        {attribute 'pytmc' := 'pv: PLC:KFE:MOTION:FFO:01'}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[PMPS_FFO]^Channel 1^Output'}
        fbFastFaultOutput1: FB_HardwareFFOutput := (bAutoReset := TRUE);
        {attribute 'pytmc' := 'pv: PLC:KFE:MOTION:FFO:02'}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[PMPS_FFO]^Channel 2^Output'}
        fbFastFaultOutput2: FB_HardwareFFOutput := (bAutoReset := TRUE);
    END_VAR


Main
^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    (*
        Only includes motor definitions for the IOC
        These are hard-coded to be Main.M#,
        but are very convenient to store in a GVL,
        hence the confusing namespace here

        This should be refactored once the IOC
        supports arbitrary ads paths for motors
    *)
        // IM1K0-XTES: 3 Axes
        {attribute 'pytmc' := 'pv: IM1K0:XTES:MMS'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[IM1K0-EL7041]^STM Status^Status^Digital input 1;
                                  .bBrakeRelease        := TIIB[IM1K0-EL2004]^Channel 1^Output;
                                  .nRawEncoderINT       := TIIB[IM1K0-EL3054]^AI Standard Channel 1^Value'}
        M1: DUT_MotionStage := (sName := 'IM1K0:XTES:MMS');
        {attribute 'pytmc' := 'pv: IM1K0:XTES:CLZ'}
        {attribute 'TcLinkTo' := '.bHome                := TIIB[IM1K0-EL1088]^Channel 2^Input;
                                  .nRawEncoderUINT      := TIIB[IM1K0-EL5101-01]^ENC Status compact^Counter value'}
        M2: DUT_MotionStage := (sName := 'IM1K0:XTES:CLZ');
        {attribute 'pytmc' := 'pv: IM1K0:XTES:CLF'}
        {attribute 'TcLinkTo' := '.bHome                := TIIB[IM1K0-EL1088]^Channel 4^Input;
                                  .nRawEncoderUINT      := TIIB[IM1K0-EL5101-01]^ENC Status compact^Counter value'}
        M3: DUT_MotionStage := (sName := 'IM1K0:XTES:CLF');

        // IM1K3-PPM: 1 Axis
        {attribute 'pytmc' := 'pv: IM1K3:PPM:MMS'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[IM1K3-EL7041]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable := TIIB[IM1K3-EL7041]^STM Status^Status^Digital input 2;
                                  .bBrakeRelease        := TIIB[IM1K3-EL2004]^Channel 1^Output;
                                  .nRawEncoderULINT     := TIIB[IM1K3-EL5042]^FB Inputs Channel 1^Position'}
        M4: DUT_MotionStage := (sName := 'IM1K3:PPM:MMS');

        // IM2K0-XTES: 3 Axes
        {attribute 'pytmc' := 'pv: IM2K0:XTES:MMS'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[IM2K0-EL7041]^STM Status^Status^Digital input 1;
                                  .bBrakeRelease        := TIIB[IM2K0-EL2004]^Channel 1^Output;
                                  .nRawEncoderULINT     := TIIB[IM2K0-EL5042]^FB Inputs Channel 1^Position'}
        M5: DUT_MotionStage := (sName := 'IM2K0:XTES:MMS');
        {attribute 'pytmc' := 'pv: IM2K0:XTES:CLZ'}
        {attribute 'TcLinkTo' := '.bHome                := TIIB[IM2K0-EL1088]^Channel 2^Input;
                                  .nRawEncoderUINT      := TIIB[IM2K0-EL7342]^ENC Status compact Channel 1^Counter value'}
        M6: DUT_MotionStage := (sName := 'IM2K0:XTES:CLZ');
        {attribute 'pytmc' := 'pv: IM2K0:XTES:CLF'}
        {attribute 'TcLinkTo' := '.bHome                := TIIB[IM2K0-EL1088]^Channel 4^Input;
                                  .nRawEncoderUINT      := TIIB[IM2K0-EL7342]^ENC Status compact Channel 2^Counter value'}
        M7: DUT_MotionStage := (sName := 'IM2K0:XTES:CLF');

        // PF1K0-WFS: 2 Axes
        {attribute 'pytmc' := 'pv: PF1K0:WFS:MMS:Y'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[PF1K0-EL7041-01]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable := TIIB[PF1K0-EL7041-01]^STM Status^Status^Digital input 2;
                                  .bBrakeRelease        := TIIB[PF1K0-EL2004]^Channel 1^Output;
                                  .nRawEncoderULINT     := TIIB[PF1K0-EL5042]^FB Inputs Channel 2^Position'}
        M8: DUT_MotionStage := (sName := 'PF1K0:WFS:MMS:Y');
        {attribute 'pytmc' := 'pv: PF1K0:WFS:MMS:Z'}
        {attribute 'TcLinkTo' := '.nRawEncoderULINT     := TIIB[PF1K0-EL5042]^FB Inputs Channel 1^Position'}
        M9: DUT_MotionStage := (sName := 'PF1K0:WFS:MMS:Z');

        // RTDSK0: 8 Axes
        M10: DUT_MotionStage;
        M11: DUT_MotionStage;
        M12: DUT_MotionStage;
        M13: DUT_MotionStage;
        M14: DUT_MotionStage;
        M15: DUT_MotionStage;
        M16: DUT_MotionStage;
        M17: DUT_MotionStage;

        // SL1K0-POWER: 4 Axes
        {attribute 'pytmc' := 'pv: SL1K0:POWER:MMS:SOUTH'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL1K0-EL7041-E1]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL1K0-EL7041-E1]^STM Status^Status^Digital input 1;
                                  .nRawEncoderINT       := TIIB[SL1K0-EL3054-E12]^AI Standard Channel 1^Value'}

        M18: DUT_MotionStage := (sName := 'SL1K0:POWER:MMS:SOUTH');
        {attribute 'pytmc' := 'pv: SL1K0:POWER:MMS:TOP'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL1K0-EL7041-E2]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL1K0-EL7041-E2]^STM Status^Status^Digital input 1;
                                  .nRawEncoderINT       := TIIB[SL1K0-EL3054-E12]^AI Standard Channel 2^Value'}
        M19: DUT_MotionStage := (sName := 'SL1K0:POWER:MMS:TOP');
        {attribute 'pytmc' := 'pv: SL1K0:POWER:MMS:NORTH'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL1K0-EL7041-E4]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL1K0-EL7041-E4]^STM Status^Status^Digital input 1;
                                  .nRawEncoderINT       := TIIB[SL1K0-EL3054-E12]^AI Standard Channel 3^Value'}
        M20: DUT_MotionStage := (sName := 'SL1K0:POWER:MMS:NORTH');
        {attribute 'pytmc' := 'pv: SL1K0:POWER:MMS:BOTTOM'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL1K0-EL7041-E5]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL1K0-EL7041-E5]^STM Status^Status^Digital input 1;
                                  .nRawEncoderINT       := TIIB[SL1K0-EL3054-E12]^AI Standard Channel 4^Value'}
        M21: DUT_MotionStage := (sName := 'SL1K0:POWER:MMS:BOTTOM');

        // SL2K0-POWER: 4 Axes
        {attribute 'pytmc' := 'pv: SL2K0:POWER:MMS:SOUTH'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL2K0-EL7041-E1]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL2K0-EL7041-E1]^STM Status^Status^Digital input 1;
                                  .nRawEncoderUINT      := TIIB[SL2K0-EL5042-E2]^FB Inputs Channel 1^Position'}
        M22: DUT_MotionStage := (sName := 'SL2K0:POWER:MMS:SOUTH');
        {attribute 'pytmc' := 'pv: SL2K0:POWER:MMS:TOP'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL2K0-EL7041-E3]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL2K0-EL7041-E3]^STM Status^Status^Digital input 1;
                                  .nRawEncoderUINT      := TIIB[SL2K0-EL5042-E2]^FB Inputs Channel 2^Position'}
        M23: DUT_MotionStage := (sName := 'SL2K0:POWER:MMS:TOP');
        {attribute 'pytmc' := 'pv: SL2K0:POWER:MMS:NORTH'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL2K0-EL7041-E5]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL2K0-EL7041-E5]^STM Status^Status^Digital input 1;
                                  .nRawEncoderUINT      := TIIB[SL2K0-EL5042-E6]^FB Inputs Channel 1^Position'}
        M24: DUT_MotionStage := (sName := 'SL2K0:POWER:MMS:NORTH');
        {attribute 'pytmc' := 'pv: SL2K0:POWER:MMS:BOTTOM'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[SL2K0-EL7041-E7]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable := TIIB[SL2K0-EL7041-E7]^STM Status^Status^Digital input 1;
                                  .nRawEncoderUINT      := TIIB[SL2K0-EL5042-E6]^FB Inputs Channel 2^Position'}
        M25: DUT_MotionStage := (sName := 'SL2K0:POWER:MMS:BOTTOM');

        // AT1K4-SOLID: 4 Axes
        M26: DUT_MotionStage;
        M27: DUT_MotionStage;
        M28: DUT_MotionStage;
        M29: DUT_MotionStage;

        // IM1K4-XTES: 3 Axes
        {attribute 'pytmc' := 'pv: IM1K4:XTES:MMS'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[IM1K4-EL7041-E1]^STM Status^Status^Digital input 1;
                                  .bBrakeRelease        := TIIB[IM1K4-EL2004-E2]^Channel 1^Output;
                                  .nRawEncoderULINT     := TIIB[IM1K4-EL5042-E3]^FB Inputs Channel 1^Position'}
        M30: DUT_MotionStage := (sName := 'IM1K4:XTES:MMS');
        {attribute 'pytmc' := 'pv: IM1K4:XTES:CLZ'}
        {attribute 'TcLinkTo' := '.bHome                := TIIB[IM1K4-EL1088-E5]^Channel 2^Input;
                                  .nRawEncoderUINT     := TIIB[IM1K4-EL7342-E4]^ENC Status compact Channel 1^Counter value'}
        M31: DUT_MotionStage := (sName := 'IM1K4:XTES:CLZ');
        {attribute 'pytmc' := 'pv: IM1K4:XTES:CLF'}
        {attribute 'TcLinkTo' := '.bHome := TIIB[IM1K4-EL1088-E5]^Channel 4^Input;
                                  .nRawEncoderUINT     := TIIB[IM1K4-EL5042-E3]^ENC Status compact Channel 2^Counter value'}
        M32: DUT_MotionStage := (sName := 'IM1K4:XTES:CLF');

        // ST1K4-TEST: 1 Axis
        {attribute 'pytmc' := 'pv: ST1K4:TEST:MMS:01'}
        {attribute 'TcLinkTo' := '.bLimitForwardEnable  := TIIB[ST1K4-EL7041-E4]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable := TIIB[ST1K4-EL7041-E4]^STM Status^Status^Digital input 2;
                                  .bBrakeRelease        := TIIB[ST1K4-EL2202-E3]^Channel 1^Output;
                                  .nRawEncoderUINT      := TIIB[ST1K4-EL7041-E4]^ENC Status compact^Counter value'}
        M33: DUT_MotionStage := (sName := 'ST1K4:TEST:MMS:01');
    END_VAR


POUs
----


FB_MPA
^^^^^^

::

    FUNCTION_BLOCK FB_MPA
    VAR_INPUT
        (*EPS Interlock Bits*)
        ibInsertOK: BOOL;
        ibRetractOK: BOOL;
        ibPMPS_OK:BOOL;
        ibOverrideInterlock:BOOL; (*if true interlocks are ignored*)
        // Reset fault
        {attribute 'pytmc' := '
        pv: FF_Reset
        '}
        i_xReset: BOOL;
        sName: STRING;
    END_VAR
    VAR_OUTPUT
        {attribute 'pytmc' := '
        pv:
        '}
        q_stAct     :    ST_MPA;
        {attribute 'pytmc' := '
        pv: MPS_FAULT
        '}
        xMPS_OK:BOOL;
        {attribute 'pytmc' := '
        pv: MOT_DONE
        '}
        xDone:Bool; // Motion is Done
    END_VAR
    VAR_IN_OUT
        io_fbFFHWO    :    FB_HardwareFFOutput;
    END_VAR
    VAR
        // PMPS
        fbFF    :    FB_FastFault :=(
            i_xAutoReset := TRUE,
            i_Desc := 'Device is moving',
            i_TypeCode := 16#1010);

        (*Init*)
        xFirstPass    :    BOOL;
        fbFSInit        :    R_TRIG;

        (* Timeouts*)
        tTimeOutDuration: TIME:= T#5S;
        tInserttimeout: TON;
        tRetracttimeout:TON;

        (*IO*)
        i_xInsertedLS    AT%I*: BOOL;
        i_xRetractedLS    AT%I*: BOOL;
        q_xInsert_DO    AT%Q*: BOOL;
        q_xRetract_DO    AT%Q*: BOOL;

        (* Reset Triggers *)
        rtInsert: R_TRIG;
        rtRemove: R_TRIG;
    END_VAR
    (*Initialize*)
    fbFSInit( CLK := TRUE, Q => xFirstPass);
    (*IO Mapping*)
    ACT_IO();

    IF xFirstPass THEN
        q_stAct.eState := INVALID;
        q_stAct.bRetract_SW := FALSE;
        q_stAct.bInsert_SW := FALSE;
    END_IF


    (* Manage States*)
    IF q_stAct.i_bInLS AND  q_stAct.i_bOutLS THEN
        q_stAct.eState:=INVALID;
    ELSIF NOT q_stAct.i_bInLS AND q_stAct.i_bOutLS THEN
        q_stAct.eState:=RETRACTED;
    ELSIF q_stAct.i_bInLS AND NOT q_stAct.i_bOutLS THEN
        q_stAct.eState:=INSERTED;
    ELSIF NOT q_stAct.i_bInLS AND NOT q_stAct.i_bOutLS THEN
        q_stAct.eState:=MOVING;
    ELSE
        q_stAct.eState:=INVALID;
    END_IF

    (*Set the Done signal*)
    xDone := (q_stAct.bRetract_SW AND q_stAct.eState=RETRACTED) OR (q_stAct.eState=INSERTED AND q_stAct.bInsert_SW);


    (*MPS FAULT*)
    (**)
    xMPS_OK := (q_stAct.bRetract_SW AND i_xRetractedLS) XOR (i_xInsertedLS AND q_stAct.bInsert_SW);
    //xMPS_OK := i_xRetractedLS XOR i_xInsertedLS;
    //xMPS_OK := (q_stAct.eState=RETRACTED) OR (q_stAct.eState=INSERTED);
    //xMPS_OK := (q_stAct.eState=RETRACTED) ;

    (*PMPS PERMISSION*)

    (* Reset the other command bit when one goes high *)
    rtInsert(CLK:=q_stAct.bInsert_SW);
    IF rtInsert.Q THEN
        q_stAct.bRetract_SW := FALSE;
    END_IF
    rtRemove(CLK:=q_stAct.bRetract_SW);
    IF rtRemove.Q THEN
        q_stAct.bInsert_SW := FALSE;
    END_IF

    (* Can't have bRetract_SW and  bInsert_SW both be true*)
    If (q_stAct.bRetract_SW) and (q_stAct.bInsert_SW) THEN
        q_stAct.bRetract_SW := FALSE;
        q_stAct.bInsert_SW := FALSE;
    END_IF

    (* Make the state consistent if we can *)
    IF NOT (q_stAct.bRetract_SW OR q_stAct.bInsert_SW) THEN
        IF q_stAct.eState = RETRACTED THEN
            q_stAct.bRetract_SW := TRUE;
        ELSIF q_stAct.eState = INSERTED THEN
            q_stAct.bInsert_SW := TRUE;
        END_IF
    END_IF

    q_stAct.bRetractOK := ibRetractOK;
    q_stAct.bInsertOK := ibInsertOK;

    (*Actuate the device*)
    q_stAct.q_bRetract := q_stAct.bRetractOK AND q_stAct.bRetract_SW;
    q_stAct.q_bInsert := q_stAct.bInsertOK AND q_stAct.bInsert_SW;

    IF q_stAct.q_bInsert THEN
        q_stAct.q_bRetract := FALSE;
        q_stAct.bRetract_SW:= FALSE;
    ELSIF q_stAct.q_bRetract THEN
        q_stAct.q_bInsert := FALSE;
        q_stAct.bInsert_SW:= FALSE;
    END_IF;




    (*Timers*)
    tInserttimeout(IN:= q_stAct.q_bInsert, PT := tTimeOutDuration );
    tRetracttimeout(IN:= q_stAct.q_bRetract, PT := tTimeOutDuration);

    ///Check moving postion timout
    IF NOT q_stAct.i_bInLS AND tInserttimeout.Q THEN
        q_stAct.bErrorPresent := TRUE;
    ELSIF NOT q_stAct.i_bOutLS AND tRetracttimeout.Q THEN
        q_stAct.bErrorPresent := TRUE;
    END_IF

    (*FAST FAULT*)
    fbFF(i_DevName := sName,
        i_xOK := xMPS_OK,
        i_xReset := i_xReset,
        io_fbFFHWO := io_fbFFHWO);

    (*Soft IO Mapping*)
    ACT_IO();

    END_FUNCTION_BLOCK
    ACTION ACT_IO:
    (*Inputs*)
    q_stAct.i_bInLS :=  i_xInsertedLS;
    q_stAct.i_bOutLS := i_xRetractedLS;

    (*outputs*)
    q_xInsert_DO:=q_stAct.q_bInsert;
    q_xRetract_DO:=q_stAct.q_bRetract;
    END_ACTION


FB_SLITS
^^^^^^^^

::

    FUNCTION_BLOCK FB_SLITS
    VAR_IN_OUT
        stTopBlade: DUT_MotionStage;
        stBottomBlade: DUT_MotionStage;
        stNorthBlade: DUT_MotionStage;
        stSouthBlade: DUT_MotionStage;
        bExecuteMotion:BOOL ;
        io_fbFFHWO    :    FB_HardwareFFOutput;
        fbArbiter: FB_Arbiter();
    END_VAR

    VAR_INPUT

        {attribute 'pytmc' := '
        pv: PMPS_OK;
        io: i;
        field: ZNAM False
        field: ONAM True
        '}
        bMoveOk:BOOL;

            (*Offsets*)
        {attribute 'pytmc' := '
        pv: Offset_Top;
        io: io;
        '}
        rEncoderOffsetTop: REAL;
        {attribute 'pytmc' := '
        pv: ZeroOffset_Bottom;
        io: io;
        '}
        rEncoderOffsetBottom: REAL;
        {attribute 'pytmc' := '
        pv: ZeroOffset_North;
        io: io;
        '}
        rEncoderOffsetNorth: REAL;
        {attribute 'pytmc' := '
        pv: ZeroOffset_South;
        io: io;
        '}
        rEncoderOffsetSouth: REAL;
        i_DevName : STRING; //device name for FFO and PMPS diagnostics
    END_VAR

    VAR
        fbTopBlade: FB_MotionStage;
        fbBottomBlade: FB_MotionStage;
        fbNorthBlade: FB_MotionStage;
        fbSouthBlade: FB_MotionStage;
        fPosTopBlade: LREAL;
        fPosBottomBlade: LREAL;
        fPosNorthBlade: LREAL;
        fPosSouthBlade: LREAL;

        (*Motion Parameters*)
        fSmallDelta: LREAL := 0.01;
        fBigDelta: LREAL := 10;
        fMaxVelocity: LREAL := 0.2;
        fHighAccel: LREAL := 0.8;
        fLowAccel: LREAL := 0.1;

        stTop: DUT_PositionState;
        stBOTTOM: DUT_PositionState;
        stNorth: DUT_PositionState;
        stSouth: DUT_PositionState;

        {attribute 'pytmc' := 'pv: TOP'}
        fbTop: FB_StatePTPMove;
        {attribute 'pytmc' := 'pv: BOTTOM'}
        fbBottom: FB_StatePTPMove;
        {attribute 'pytmc' := 'pv: NORTH'}
        fbNorth: FB_StatePTPMove;
        {attribute 'pytmc' := 'pv: SOUTH'}
        fbSouth: FB_StatePTPMove;

        (*EPICS pvs*)
        {attribute 'pytmc' := '
        pv: XWID_REQ;
        io: io;
        '}
        rReqApertureSizeX : REAL;
        {attribute 'pytmc' := '
        pv: YWID_REQ;
        io: io;
        '}
        rReqApertureSizeY : REAL;
        {attribute 'pytmc' := '
        pv: XCEN_REQ;
        io: io;
        '}
        rReqCenterX: REAL;
        {attribute 'pytmc' := '
        pv: YCEN_REQ;
        io: io;
        '}
        rReqCenterY: REAL;

        {attribute 'pytmc' := '
        pv: ACTUAL_XWIDTH;
        io: io;
        '}
        rActApertureSizeX : REAL;

        {attribute 'pytmc' := '
        pv: ACTUAL_YWIDTH;
        io: io;
        '}
        rActApertureSizeY : REAL;
        {attribute 'pytmc' := '
        pv: ACTUAL_XCENTER;
        io: io;
        '}
        rActCenterX: REAL;
        {attribute 'pytmc' := '
        pv: ACTUAL_YCENTER;
        io: io;
        '}
        rActCenterY: REAL;

        {attribute 'pytmc' := '
        pv: XCEN_SETZERO;
        io: io;
        '}
        rSetCenterX: BOOL;
        {attribute 'pytmc' := '
        pv: YCEN_SETZERO;
        io: io;
        '}
        rSetCenterY: BOOL;


        {attribute 'pytmc' := '
        pv: OPEN;
        io: io;
        field: ZNAM False
        field: ONAM True
        '}
        bOpen: BOOL;

        {attribute 'pytmc' := '
        pv: CLOSE;
        io: io;
        field: ZNAM False
        field: ONAM True
        '}
        bClose: BOOL;

        {attribute 'pytmc' := '
        pv: BLOCK;
        io: io;
        field: ZNAM False
        field: ONAM True
        '}
        bBlock: BOOL;



            //Local variables
        bInit: BOOL :=true;
        rTrig_Block: R_TRIG;
        rTrig_Open: R_TRIG;
        rTrig_Close: R_TRIG;

        //old values
        rOldReqApertureSizeX : REAL;
        rOldReqApertureSizeY : REAL;
        rOldReqCenterX: REAL;
        rOldReqCenterY: REAL;

        bExecuteMotionX: BOOL;
        bExecuteMotionY: BOOL;


        fPosBlock: LREAL;
        fPosClose: LREAL;
        fPosOpen: LREAL;

        stSetPositionOptions:ST_SetPositionOptions;
        fbSetPosition_TOP: MC_SetPosition;
        fbSetPosition_Bottom: MC_SetPosition;
        fbSetPosition_North: MC_SetPosition;
        fbSetPosition_South: MC_SetPosition;

        // For logging
        fbLogger : FB_LogMessage := (eSubsystem:=E_SubSystem.MOTION);
        tErrorPresent : R_TRIG;
        tAction : R_TRIG;
        tOverrideActivated : R_TRIG;

        FFO    :    FB_FastFault :=(
            i_DevName := 'Slits',
            i_Desc := 'Fault occurs when center is greated than that requested',
            i_TypeCode := 16#1010);

        AptArrayStatus AT %Q* : ST_PMPS_Aperture_IO;
        AptArrayReq AT %I* : ST_PMPS_Aperture_IO;

        bTest: BOOL;

    END_VAR


    END_FUNCTION_BLOCK
    ACTION ACT_BLOCK:
    rTrig_Block (CLK:= bBlock);
    rTrig_Open (CLK:= bOpen);
    rTrig_Close (CLK:= bClose);

    if (rTrig_Block.Q) THEN
        //BLOCK

        bBlock := false;
    END_IF

    if (rTrig_Open.Q) THEN


        bOpen := false;
    END_IF

    if (rTrig_Close.Q) THEN


        bClose := false;
    END_IF
    END_ACTION
    ACTION ACT_CalculatePositions:
    //check if requested center or gap has changed
    //check that the requested values are within acceptable motion range
    IF (rOldReqApertureSizeX <> rReqApertureSizeX) THEN
        IF (rReqApertureSizeX <= AptArrayReq.Width)  THEN
            rOldReqApertureSizeX := rReqApertureSizeX;
            bExecuteMotionX := TRUE;
            fbLogger(sMsg:='Requested new X gap.', eSevr:=TcEventSeverity.Verbose);
        ELSE
            fbLogger(sMsg:='Requested new X gap is larger than PMPS request.', eSevr:=TcEventSeverity.Verbose);
        END_IF
      //  ELSE
        //    rReqApertureSizeX := rActApertureSizeX;
    END_IF

    IF (rOldReqCenterX <> rReqCenterX) THEN
        rOldReqCenterX := rReqCenterX;
        bExecuteMotionX := TRUE;
        fbLogger(sMsg:='Requested new X center', eSevr:=TcEventSeverity.Verbose);
       // ELSE
          //  rReqCenterX := rActCenterX;
    END_IF

    IF (rOldReqApertureSizeY <> rReqApertureSizeY) THEN
        IF rReqApertureSizeY <= AptArrayReq.Height THEN
            rOldReqApertureSizeY := rReqApertureSizeY;
            bExecuteMotionY := TRUE;
            fbLogger(sMsg:='Requested new Y gap.', eSevr:=TcEventSeverity.Verbose);
        ELSE
            fbLogger(sMsg:='Requested new Y gap is larger than PMPS request.', eSevr:=TcEventSeverity.Verbose);
        END_IF
       // ELSE
           // rReqApertureSizeY := rActApertureSizeY;
    END_IF

    IF (rOldReqCenterY <> rReqCenterY) THEN
        rOldReqCenterY := rReqCenterY;
        bExecuteMotionY := TRUE;
        fbLogger(sMsg:='Requested new Y center.', eSevr:=TcEventSeverity.Verbose);
       // ELSE
          //  rReqCenterY := rActCenterY;
    END_IF


    //Calculate requested target positions from requested gap and center
    fPosTopBlade := (rReqApertureSizeY/2) + (rReqCenterY + rEncoderOffsetTop) ;
    fPosBottomBlade := (-1*rReqApertureSizeY/2) + (rReqCenterY+rEncoderOffsetBottom);

    fPosNorthBlade := (rReqApertureSizeX/2) + (rReqCenterX + rEncoderOffsetNorth);
    fPosSouthBlade := (-1*rReqApertureSizeX/2) + (rReqCenterX + rEncoderOffsetSouth);


    //Calculate actual gap and center from actual stages positions
    rActApertureSizeX := LREAL_TO_REAL((stNorthBlade.stAxisStatus.fActPosition - rEncoderOffsetNorth) - (stSouthBlade.stAxisStatus.fActPosition- rEncoderOffsetSouth));

    rActApertureSizeY := LREAL_TO_REAL((stTopBlade.stAxisStatus.fActPosition - rEncoderOffsetTop) - (stBottomBlade.stAxisStatus.fActPosition - rEncoderOffsetBottom));

    rActCenterX := LREAL_TO_REAL((((stNorthBlade.stAxisStatus.fActPosition - rEncoderOffsetNorth)  + (stSouthBlade.stAxisStatus.fActPosition - rEncoderOffsetSouth ))/2));

    rActCenterY := LREAL_TO_REAL((((stTopBlade.stAxisStatus.fActPosition - rEncoderOffsetTop) + (stBottomBlade.stAxisStatus.fActPosition - rEncoderOffsetBottom))/2));



    //Update PMPS Arbiter with the Actual Size and Center of the Aperture
    END_ACTION
    ACTION ACT_Home:

    END_ACTION
    ACTION ACT_Init:
    //  init the motion stages parameters
    IF ( bInit) THEN
        stTopBlade.bHardwareEnable := TRUE;
        stBottomBlade.bHardwareEnable := TRUE;
        stNorthBlade.bHardwareEnable := TRUE;
        stSouthBlade.bHardwareEnable := TRUE;
        stTopBlade.bPowerSelf :=TRUE;
        stBottomBlade.bPowerSelf :=TRUE;
        stNorthBlade.bPowerSelf :=TRUE;
        stSouthBlade.bPowerSelf :=TRUE;
        stTopBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
        stBottomBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
        stNorthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
        stSouthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
        FFO.i_DevName := i_DevName;
    END_IF
    END_ACTION
    ACTION ACT_Motion:
    // Instantiate Function block for all the blades
    fbTopBlade(stMotionStage:=stTopBlade);
    fbBottomBlade(stMotionStage:=stBottomBlade);
    fbNorthBlade(stMotionStage:=stNorthBlade);
    fbSouthBlade(stMotionStage:=stSouthBlade);

    // PTP Motion for each blade
    stTop.sName := 'Top';
    stTop.fPosition := fPosTopBlade;
    stTop.fDelta := fSmallDelta;
    stTop.fVelocity := fMaxVelocity;
    stTop.fAccel := fHighAccel;
    stTop.fDecel := fHighAccel;

    stBOTTOM.sName := 'Bottom';
    stBOTTOM.fPosition := fPosBottomBlade;
    stBOTTOM.fDelta := fSmallDelta;
    stBOTTOM.fVelocity := fMaxVelocity;
    stBOTTOM.fAccel := fHighAccel;
    stBOTTOM.fDecel := fHighAccel;

    stNorth.sName := 'North';
    stNorth.fPosition := fPosNorthBlade;
    stNorth.fDelta := fSmallDelta;
    stNorth.fVelocity := fMaxVelocity;
    stNorth.fAccel := fHighAccel;
    stNorth.fDecel := fHighAccel;

    stSouth.sName := 'South';
    stSouth.fPosition := fPosSouthBlade;
    stSouth.fDelta := fSmallDelta;
    stSouth.fVelocity := fMaxVelocity;
    stSouth.fAccel := fHighAccel;
    stSouth.fDecel := fHighAccel;

    IF (bExecuteMotionY) THEN
        fbTop.bExecute := fbBottom.bExecute := bExecuteMotionY;
        bExecuteMotionY:= FALSE;
    END_IF

    IF (bExecuteMotionX) THEN
        fbNorth.bExecute := fbSouth.bExecute := bExecuteMotionX;
        bExecuteMotionX:= FALSE;
    END_IF


    fbTop(
        stPositionState:=stTop,
        bMoveOk:=bMoveOk,
        stMotionStage:=stTopBlade);

    fbBottom(
        stPositionState:=stBOTTOM,
        bMoveOk:=bMoveOk,
        stMotionStage:=stBottomBlade);

    fbNorth(
        stPositionState:=stNorth,
        bMoveOk:=bMoveOk,
        stMotionStage:=stNorthBlade);

    fbSouth(
        stPositionState:=stSouth,
        bMoveOk:=bMoveOk,
        stMotionStage:=stSouthBlade);
    END_ACTION
    ACTION ACT_Zero:
    //ZERO BIAS

    // Set Y center to zero

    // Set X center to zero
    (*
    if (rSetCenterY)THEN
            rSetCenterY := false;
            // Set Current Position
            fbSetPosition_TOP.Position :=  stTopBlade.stAxisStatus.fActPosition - rActCenterY ;
            fbSetPosition_TOP.Execute := TRUE;
            fbSetPosition_Bottom.Position := stBottomBlade.stAxisStatus.fActPosition - rActCenterY;
            fbSetPosition_Bottom.Execute := TRUE;
    END_IF

    if (rSetCenterX)THEN
            rSetCenterX := false;
            // Set Current Position
            fbSetPosition_North.Position := stNorthBlade.stAxisStatus.fActPosition - rActCenterX ;
            fbSetPosition_North.Execute := TRUE;
            fbSetPosition_South.Position := stSouthBlade.stAxisStatus.fActPosition - rActCenterX ; ;
            fbSetPosition_South.Execute := TRUE;
    END_IF


    //Reset
    if (fbSetPosition_TOP.Done ) THEN
        fbSetPosition_TOP.Execute := FALSE;
    END_IF
    if (fbSetPosition_Bottom.Done ) THEN
        fbSetPosition_Bottom.Execute := FALSE;
    END_IF
    if (fbSetPosition_North.Done ) THEN
        fbSetPosition_North.Execute := FALSE;
    END_IF
    if (fbSetPosition_South.Done ) THEN
        fbSetPosition_South.Execute := FALSE;
    END_IF

    // Set Encoder Position
    //Clear position lag error
    stSetPositionOptions.ClearPositionLag := TRUE;
    fbSetPosition_TOP(
        Axis:=  stTopBlade.Axis ,
        Execute:= ,
        Position:= 0 ,
        Mode:= FALSE,
        Options:= stSetPositionOptions,
        Done=> ,
        Busy=> ,
        Error=> ,
        ErrorID=> );
    fbSetPosition_Bottom(
        Axis:= stBottomBlade.Axis ,
        Execute:= ,
        Position:= 0 ,
        Mode:= FALSE,
        Options:= stSetPositionOptions,
        Done=> ,
        Busy=> ,
        Error=> ,
        ErrorID=> );
    fbSetPosition_North(
        Axis:= stNorthBlade.Axis ,
        Execute:= ,
        Position:= 0 ,
        Mode:= FALSE,
        Options:= stSetPositionOptions,
        Done=> ,
        Busy=> ,
        Error=> ,
        ErrorID=> );
    fbSetPosition_South(
        Axis:= stSouthBlade.Axis ,
        Execute:= ,
        Position:= 0 ,
        Mode:= FALSE,
        Options:= stSetPositionOptions,
        Done=> ,
        Busy=> ,
        Error=> ,
        ErrorID=> );

        *)
    END_ACTION


FB_SLITS_POWER
^^^^^^^^^^^^^^

::

    FUNCTION_BLOCK FB_SLITS_POWER EXTENDS FB_SLITS
    VAR_INPUT
    END_VAR
    VAR
         {attribute 'pytmc' := '
            pv: FSW
        '}
        fbFlowSwitch: FB_XTES_Flowswitch;


        //RTDs
        {attribute 'pytmc' := '
            pv: TOP:RTD:01
        '}
        RTD_TOP_1: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: TOP:RTD:02
        '}
        RTD_TOP_2: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: BOTTOM:RTD:01
        '}
        RTD_Bottom_1: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: BOTTOM:RTD:02
        '}
        RTD_Bottom_2: FB_TempSensor;

        {attribute 'pytmc' := '
            pv: NORTH:RTD:01
        '}
        RTD_North_1: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: NORTH:RTD:02
        '}
        RTD_North_2: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: SOUTH:RTD:01
        '}
        RTD_South_1: FB_TempSensor;
        {attribute 'pytmc' := '
            pv: SOUTH:RTD:02
        '}
        RTD_South_2: FB_TempSensor;


    END_VAR
    ACT_init();

    // Instantiate Function block for all the blades
    ACT_Motion();
    //SET and GET the requested and Actual values
    ACT_CalculatePositions();
    //ACT_BLOCK();
    ACT_RTDs();

    END_FUNCTION_BLOCK
    ACTION ACT_RTDs:
    ////RTDs
    RTD_TOP_1();
    RTD_TOP_2();
    RTD_Bottom_1();
    RTD_Bottom_2();
    RTD_North_1();
    RTD_North_2();
    RTD_South_1();
    RTD_South_2();

    //Flow Switch
    fbFlowSwitch();
    END_ACTION


PRG_1_PlcTask
^^^^^^^^^^^^^

::

    PROGRAM PRG_1_PlcTask
    VAR
    END_VAR
    PRG_2_PMPS_PRE();

    PRG_IM1K0_XTES();
    PRG_IM1K3_PPM();
    PRG_IM2K0_XTES();
    PRG_PF1K0_WFS();
    PRG_RTDSK0();
    PRG_SL1K0_POWER();
    PRG_SL2K0_POWER();

    PRG_AT1K4_SOLID();
    PRG_IM1K4_XTES();
    PRG_ST1K4_TEST();

    PRG_3_PMPS_POST();
    PRG_4_LOG();

    END_PROGRAM


PRG_2_PMPS_PRE
^^^^^^^^^^^^^^

::

    PROGRAM PRG_2_PMPS_PRE
    VAR
    END_VAR


    END_PROGRAM


PRG_3_PMPS_POST
^^^^^^^^^^^^^^^

::

    PROGRAM PRG_3_PMPS_POST
    VAR
        fbArbiterIO: FB_SubSysToArbiter_IO;
    END_VAR
    GVL.fbFastFaultOutput1.Execute();
    GVL.fbFastFaultOutput2.Execute();

    fbArbiterIO(
        Arbiter:=GVL.fbArbiter,
        fbFFHWO:=GVL.fbFastFaultOutput1);

    END_PROGRAM


PRG_4_LOG
^^^^^^^^^

::

    PROGRAM PRG_4_LOG
    VAR
        fbLogHandler: FB_LogHandler;
    END_VAR
    fbLogHandler();

    END_PROGRAM


PRG_AT1K4_SOLID
^^^^^^^^^^^^^^^

::

    PROGRAM PRG_AT1K4_SOLID
    VAR
    END_VAR
    // M26, Axis 26
    // M27, Axis 27
    // M28, Axis 28
    // M29, Axis 29

    END_PROGRAM


PRG_IM1K0_XTES
^^^^^^^^^^^^^^

::

    PROGRAM PRG_IM1K0_XTES
    VAR
        {attribute 'pytmc' := '
            pv: IM1K0:XTES
            io: io
        '}
        {attribute 'TcLinkTo' := '.bZoomEndFwd := TIIB[IM1K0-EL1088]^Channel 1^Input;
                                  .bZoomEndBwd := TIIB[IM1K0-EL1088]^Channel 2^Input;
                                  .bFocusEndFwd := TIIB[IM1K0-EL1088]^Channel 3^Input;
                                  .bFocusEndBwd := TIIB[IM1K0-EL1088]^Channel 4^Input;
                                  .fbOpal.bOpalPower := TIIB[IM1K0-EL2004]^Channel 2^Output;
                                  .fbLED.bLedPower := TIIB[IM1K0-EL2004]^Channel 3^Output'}
        fbIM1K0: FB_XPIM;
        {attribute 'TcLinkTo' := '.Status := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Status;
                                  .D[0] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 0;
                                  .D[1] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 1;
                                  .D[2] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 2;
                                  .D[3] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 3;
                                  .D[4] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 4;
                                  .D[5] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 5;
                                  .D[6] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 6;
                                  .D[7] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 7;
                                  .D[8] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 8;
                                  .D[9] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 9;
                                  .D[10] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 10;
                                  .D[11] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 11;
                                  .D[12] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 12;
                                  .D[13] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 13;
                                  .D[14] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 14;
                                  .D[15] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 15;
                                  .D[16] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 16;
                                  .D[17] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 17;
                                  .D[18] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 18;
                                  .D[19] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 19;
                                  .D[20] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 20;
                                  .D[21] := TIIB[IM1K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 21'}
        stEL6In AT %I*: EL6InData22b;
        {attribute 'TcLinkTo' := '.Ctrl := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Ctrl;
                                  .D[0] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 0;
                                  .D[1] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 1;
                                  .D[2] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 2;
                                  .D[3] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 3;
                                  .D[4] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 4;
                                  .D[5] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 5;
                                  .D[6] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 6;
                                  .D[7] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 7;
                                  .D[8] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 8;
                                  .D[9] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 9;
                                  .D[10] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 10;
                                  .D[11] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 11;
                                  .D[12] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 12;
                                  .D[13] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 13;
                                  .D[14] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 14;
                                  .D[15] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 15;
                                  .D[16] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 16;
                                  .D[17] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 17;
                                  .D[18] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 18;
                                  .D[19] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 19;
                                  .D[20] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 20;
                                  .D[21] := TIIB[IM1K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 21'}
        stEL6Out AT %Q*: EL6OutData22b;
    END_VAR
    fbIM1K0.nTransitionAssertionID := 16#2100;
    fbIM1K0.nUnknownAssertionID := 16#2109;

    fbIM1K0.stOut.fPosition := 0;
    fbIM1K0.stOut.bUseRawCounts := FALSE;
    fbIM1K0.stOut.nRequestAssertionID := 16#2101;
    fbIM1K0.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K0.stOut.bValid := TRUE;

    fbIM1K0.stYag.fPosition := -27.65;
    fbIM1K0.stYag.bUseRawCounts := FALSE;
    fbIM1K0.stYag.nRequestAssertionID := 16#2102;
    fbIM1K0.stYag.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K0.stYag.bValid := TRUE;

    fbIM1K0.stDiamond.fPosition := -57.65;
    fbIM1K0.stDiamond.bUseRawCounts := FALSE;
    fbIM1K0.stDiamond.nRequestAssertionID := 16#2103;
    fbIM1K0.stDiamond.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K0.stDiamond.bValid := TRUE;

    fbIM1K0.stReticle.fPosition := -87.65;
    fbIM1K0.stReticle.bUseRawCounts := FALSE;
    fbIM1K0.stReticle.nRequestAssertionID := 16#2104;
    fbIM1K0.stReticle.stBeamParams := PMPS_GVL.cst0RateBeam;
    fbIM1K0.stReticle.bValid := TRUE;

    fbIM1K0(
        fbArbiter := GVL.fbArbiter,
        fbFFHWO := GVL.fbFastFaultOutput1,
        stYStage := Main.M1,
        stZoomStage := Main.M2,
        stFocusStage := Main.M3,
        stEl6In := stEL6In,
        stEl6Out := stEl6Out);

    END_PROGRAM


PRG_IM1K3_PPM
^^^^^^^^^^^^^

::

    PROGRAM PRG_IM1K3_PPM
    VAR
        {attribute 'pytmc' := '
            pv: IM1K3:PPM
            io: io
        '}
        {attribute 'TcLinkTo' := '.fbGige.iIlluminatorINT := TIIB[IM1K3-EL4004]^AO Outputs Channel 1^Analog output;
                                  .fbGige.bGigePower := TIIB[IM1K3-EL2004]^Channel 2^Output;
                                  .fbPowerMeter.iVoltageINT := TIIB[IM1K3-EL3062]^AI Standard Channel 1^Value;
                                  .fbPowerMeter.fbThermoCouple.bError := TIIB[IM1K3-EL3314]^TC Inputs Channel 1^Status^Error;
                                  .fbPowerMeter.fbThermoCouple.bUnderrange := TIIB[IM1K3-EL3314]^TC Inputs Channel 1^Status^Underrange;
                                  .fbPowerMeter.fbThermoCouple.bOverrange := TIIB[IM1K3-EL3314]^TC Inputs Channel 1^Status^Overrange;
                                  .fbPowerMeter.fbThermoCouple.iRaw := TIIB[IM1K3-EL3314]^TC Inputs Channel 1^Value;
                                  .fbYagThermoCouple.bError := TIIB[IM1K3-EL3314]^TC Inputs Channel 2^Status^Error;
                                  .fbYagThermoCouple.bUnderrange := TIIB[IM1K3-EL3314]^TC Inputs Channel 2^Status^Underrange;
                                  .fbYagThermoCouple.bOverrange := TIIB[IM1K3-EL3314]^TC Inputs Channel 2^Status^Overrange;
                                  .fbYagThermoCouple.iRaw := TIIB[IM1K3-EL3314]^TC Inputs Channel 2^Value'}
        fbIM1K3: FB_PPM;
    END_VAR
    fbIM1K3.nTransitionAssertionID := 16#2130;
    fbIM1K3.nUnknownAssertionID := 16#2139;

    fbIM1K3.stOut.fPosition := -9.1;
    fbIM1K3.stOut.bUseRawCounts := FALSE;
    fbIM1K3.stOut.nRequestAssertionID := 16#2131;
    fbIM1K3.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K3.stOut.bValid := TRUE;

    fbIM1K3.stPower.fPosition := -48.2;
    fbIM1K3.stPower.bUseRawCounts := FALSE;
    fbIM1K3.stPower.nRequestAssertionID := 16#2132;
    fbIM1K3.stPower.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K3.stPower.bValid := TRUE;

    fbIM1K3.stYag1.fPosition := -72.2;
    fbIM1K3.stYag1.bUseRawCounts := FALSE;
    fbIM1K3.stYag1.nRequestAssertionID := 16#2133;
    fbIM1K3.stYag1.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K3.stYag1.bValid := TRUE;

    fbIM1K3.stYag2.fPosition := -98.21;
    fbIM1K3.stYag2.bUseRawCounts := FALSE;
    fbIM1K3.stYag2.nRequestAssertionID := 16#2134;
    fbIM1K3.stYag2.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K3.stYag2.bValid := TRUE;

    fbIM1K3(
        fbArbiter := GVL.fbArbiter,
        fbFFHWO := GVL.fbFastFaultOutput2,
        stYStage := Main.M4);

    END_PROGRAM


PRG_IM1K4_XTES
^^^^^^^^^^^^^^

::

    PROGRAM PRG_IM1K4_XTES
    VAR
        {attribute 'pytmc' := '
            pv: IM1K4:XTES
            io: io
        '}
        {attribute 'TcLinkTo' := '.bZoomEndFwd := TIIB[IM1K4-EL1088-E5]^Channel 1^Input;
                                  .bZoomEndBwd := TIIB[IM1K4-EL1088-E5]^Channel 2^Input;
                                  .bFocusEndFwd := TIIB[IM1K4-EL1088-E5]^Channel 3^Input;
                                  .bFocusEndBwd := TIIB[IM1K4-EL1088-E5]^Channel 4^Input;
                                  .fbOpal.bOpalPower := TIIB[IM1K4-EL2004-E2]^Channel 2^Output;
                                  .fbLED.bLedPower := TIIB[IM1K4-EL2004-E2]^Channel 3^Output'}
        fbIM1K4: FB_XPIM;
        {attribute 'TcLinkTo' := '.Status := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Status;
                                  .D[0] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 0;
                                  .D[1] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 1;
                                  .D[2] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 2;
                                  .D[3] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 3;
                                  .D[4] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 4;
                                  .D[5] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 5;
                                  .D[6] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 6;
                                  .D[7] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 7;
                                  .D[8] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 8;
                                  .D[9] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 9;
                                  .D[10] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 10;
                                  .D[11] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 11;
                                  .D[12] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 12;
                                  .D[13] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 13;
                                  .D[14] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 14;
                                  .D[15] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 15;
                                  .D[16] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 16;
                                  .D[17] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 17;
                                  .D[18] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 18;
                                  .D[19] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 19;
                                  .D[20] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 20;
                                  .D[21] := TIIB[IM1K4-EL6002-E6]^COM TxPDO-Map Inputs Channel 1^Data In 21'}
        stEL6In AT %I*: EL6InData22b;
        {attribute 'TcLinkTo' := '.Ctrl := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Ctrl;
                                  .D[0] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 0;
                                  .D[1] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 1;
                                  .D[2] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 2;
                                  .D[3] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 3;
                                  .D[4] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 4;
                                  .D[5] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 5;
                                  .D[6] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 6;
                                  .D[7] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 7;
                                  .D[8] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 8;
                                  .D[9] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 9;
                                  .D[10] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 10;
                                  .D[11] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 11;
                                  .D[12] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 12;
                                  .D[13] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 13;
                                  .D[14] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 14;
                                  .D[15] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 15;
                                  .D[16] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 16;
                                  .D[17] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 17;
                                  .D[18] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 18;
                                  .D[19] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 19;
                                  .D[20] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 20;
                                  .D[21] := TIIB[IM1K4-EL6002-E6]^COM RxPDO-Map Outputs Channel 1^Data Out 21'}
        stEL6Out AT %Q*: EL6OutData22b;
    END_VAR
    fbIM1K4.nTransitionAssertionID := 16#2140;
    fbIM1K4.nUnknownAssertionID := 16#2149;

    fbIM1K4.stOut.fPosition := 0;
    fbIM1K4.stOut.bUseRawCounts := FALSE;
    fbIM1K4.stOut.nRequestAssertionID := 16#2141;
    fbIM1K4.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K4.stOut.bValid := TRUE;

    fbIM1K4.stYag.fPosition := -88.87;
    fbIM1K4.stYag.bUseRawCounts := FALSE;
    fbIM1K4.stYag.nRequestAssertionID := 16#2142;
    fbIM1K4.stYag.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K4.stYag.bValid := TRUE;

    fbIM1K4.stDiamond.fPosition := -58.87;
    fbIM1K4.stDiamond.bUseRawCounts := FALSE;
    fbIM1K4.stDiamond.nRequestAssertionID := 16#2143;
    fbIM1K4.stDiamond.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM1K4.stDiamond.bValid := TRUE;

    fbIM1K4.stReticle.fPosition := -28.87;
    fbIM1K4.stReticle.bUseRawCounts := FALSE;
    fbIM1K4.stReticle.nRequestAssertionID := 16#2144;
    fbIM1K4.stReticle.stBeamParams := PMPS_GVL.cst0RateBeam;
    fbIM1K4.stReticle.bValid := TRUE;

    fbIM1K4(
        fbArbiter := GVL.fbArbiter,
        fbFFHWO := GVL.fbFastFaultOutput1,
        stYStage := Main.M30,
        stZoomStage := Main.M31,
        stFocusStage := Main.M32,
        stEl6In := stEL6In,
        stEl6Out := stEl6Out);

    END_PROGRAM


PRG_IM2K0_XTES
^^^^^^^^^^^^^^

::

    PROGRAM PRG_IM2K0_XTES
    VAR
        {attribute 'pytmc' := '
            pv: IM2K0:XTES
            io: io
        '}
        {attribute 'TcLinkTo' := '.bZoomEndFwd := TIIB[IM2K0-EL1088]^Channel 1^Input;
                                  .bZoomEndBwd := TIIB[IM2K0-EL1088]^Channel 2^Input;
                                  .bFocusEndFwd := TIIB[IM2K0-EL1088]^Channel 3^Input;
                                  .bFocusEndBwd := TIIB[IM2K0-EL1088]^Channel 4^Input;
                                  .fbOpal.bOpalPower := TIIB[IM2K0-EL2004]^Channel 2^Output;
                                  .fbLED.bLedPower := TIIB[IM2K0-EL2004]^Channel 3^Output'}
        fbIM2K0: FB_XPIM;
        {attribute 'TcLinkTo' := '.Status := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Status;
                                  .D[0] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 0;
                                  .D[1] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 1;
                                  .D[2] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 2;
                                  .D[3] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 3;
                                  .D[4] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 4;
                                  .D[5] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 5;
                                  .D[6] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 6;
                                  .D[7] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 7;
                                  .D[8] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 8;
                                  .D[9] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 9;
                                  .D[10] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 10;
                                  .D[11] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 11;
                                  .D[12] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 12;
                                  .D[13] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 13;
                                  .D[14] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 14;
                                  .D[15] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 15;
                                  .D[16] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 16;
                                  .D[17] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 17;
                                  .D[18] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 18;
                                  .D[19] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 19;
                                  .D[20] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 20;
                                  .D[21] := TIIB[IM2K0-EL6002]^COM TxPDO-Map Inputs Channel 1^Data In 21'}
        stEL6In AT %I*: EL6InData22b;
        {attribute 'TcLinkTo' := '.Ctrl := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Ctrl;
                                  .D[0] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 0;
                                  .D[1] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 1;
                                  .D[2] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 2;
                                  .D[3] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 3;
                                  .D[4] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 4;
                                  .D[5] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 5;
                                  .D[6] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 6;
                                  .D[7] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 7;
                                  .D[8] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 8;
                                  .D[9] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 9;
                                  .D[10] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 10;
                                  .D[11] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 11;
                                  .D[12] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 12;
                                  .D[13] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 13;
                                  .D[14] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 14;
                                  .D[15] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 15;
                                  .D[16] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 16;
                                  .D[17] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 17;
                                  .D[18] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 18;
                                  .D[19] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 19;
                                  .D[20] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 20;
                                  .D[21] := TIIB[IM2K0-EL6002]^COM RxPDO-Map Outputs Channel 1^Data Out 21'}
        stEL6Out AT %Q*: EL6OutData22b;
    END_VAR
    fbIM2K0.nTransitionAssertionID := 16#2200;
    fbIM2K0.nUnknownAssertionID := 16#2209;

    fbIM2K0.stOut.fPosition := 0;
    fbIM2K0.stOut.bUseRawCounts := FALSE;
    fbIM2K0.stOut.nRequestAssertionID := 16#2201;
    fbIM2K0.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM2K0.stOut.bValid := TRUE;

    fbIM2K0.stYag.fPosition := -87.65;
    fbIM2K0.stYag.bUseRawCounts := FALSE;
    fbIM2K0.stYag.nRequestAssertionID := 16#2202;
    fbIM2K0.stYag.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM2K0.stYag.bValid := TRUE;

    fbIM2K0.stDiamond.fPosition := -57.65;
    fbIM2K0.stDiamond.bUseRawCounts := FALSE;
    fbIM2K0.stDiamond.nRequestAssertionID := 16#2203;
    fbIM2K0.stDiamond.stBeamParams := PMPS_GVL.cstFullBeam;
    fbIM2K0.stDiamond.bValid := TRUE;

    fbIM2K0.stReticle.fPosition := -27.65;
    fbIM2K0.stReticle.bUseRawCounts := FALSE;
    fbIM2K0.stReticle.nRequestAssertionID := 16#2204;
    fbIM2K0.stReticle.stBeamParams := PMPS_GVL.cst0RateBeam;
    fbIM2K0.stReticle.bValid := TRUE;

    fbIM2K0(
        fbArbiter := GVL.fbArbiter,
        fbFFHWO := GVL.fbFastFaultOutput1,
        stYStage := Main.M5,
        stZoomStage := Main.M6,
        stFocusStage := Main.M7,
        stEl6In := stEL6In,
        stEl6Out := stEl6Out);

    END_PROGRAM


PRG_PF1K0_WFS
^^^^^^^^^^^^^

::

    PROGRAM PRG_PF1K0_WFS
    VAR
        {attribute 'pytmc' := '
            pv: PF1K0:WFS
            io: io
        '}
        {attribute 'TcLinkTo' := '.fbThermoCouple1.bError := TIIB[PF1K0-EL3314]^TC Inputs Channel 1^Status^Error;
                                  .fbThermoCouple1.bUnderrange := TIIB[PF1K0-EL3314]^TC Inputs Channel 1^Status^Underrange;
                                  .fbThermoCouple1.bOverrange := TIIB[PF1K0-EL3314]^TC Inputs Channel 1^Status^Overrange;
                                  .fbThermoCouple1.iRaw := TIIB[PF1K0-EL3314]^TC Inputs Channel 1^Value;
                                  .fbThermoCouple2.bError := TIIB[PF1K0-EL3314]^TC Inputs Channel 2^Status^Error;
                                  .fbThermoCouple2.bUnderrange := TIIB[PF1K0-EL3314]^TC Inputs Channel 2^Status^Underrange;
                                  .fbThermoCouple2.bOverrange := TIIB[PF1K0-EL3314]^TC Inputs Channel 2^Status^Overrange;
                                  .fbThermoCouple2.iRaw := TIIB[PF1K0-EL3314]^TC Inputs Channel 2^Value'}
        fbPF1K0: FB_WFS;

        stSiBP: ST_BeamParams := PMPS_GVL.cstFullBeam;
        stFoilBP: ST_BeamParams := PMPS_GVL.cstFullBeam;
    END_VAR
    (*
       Avoid damage peak between 1.6 keV and 3.2 keV
       Boundaries are upper boundary of eV range
       250,    270,    400,    540,    850,   1.15E3, 1.25E3, 1.45E3,
       1.55E3, 1.65E3, 1.75E3, 1.82E3, 2.0E3, 3.2E3,  5.0E3,  7.1E3
       1       1       1       1       1      1       1       1
       1       0       0       0       0      0       1       1
    *)
    stSiBP.neVRange := 2#1111_1111_1000_0011;
    // Drop transmission to 20%
    stSiBP.nTran := 20;

    // Drop transmission to 10%
    stFoilBP.nTran := 10;

    fbPF1K0.nTransitionAssertionID := 16#3100;
    fbPF1K0.nUnknownAssertionID := 16#3109;

    fbPF1K0.stOut.fPosition := -15;
    fbPF1K0.stOut.bUseRawCounts := FALSE;
    fbPF1K0.stOut.nRequestAssertionID := 16#3101;
    fbPF1K0.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    fbPF1K0.stOut.bValid := TRUE;

    fbPF1K0.stTarget1.fPosition := -96.623;
    fbPF1K0.stTarget1.bUseRawCounts := FALSE;
    fbPF1K0.stTarget1.nRequestAssertionID := 16#3102;
    fbPF1K0.stTarget1.stBeamParams := stSiBP;
    fbPF1K0.stTarget1.bValid := TRUE;

    fbPF1K0.stTarget2.fPosition := -82.25;
    fbPF1K0.stTarget2.bUseRawCounts := FALSE;
    fbPF1K0.stTarget2.nRequestAssertionID := 16#3103;
    fbPF1K0.stTarget2.stBeamParams := stSiBP;
    fbPF1K0.stTarget2.bValid := TRUE;

    fbPF1K0.stTarget3.fPosition := -67.874;
    fbPF1K0.stTarget3.bUseRawCounts := FALSE;
    fbPF1K0.stTarget3.nRequestAssertionID := 16#3104;
    fbPF1K0.stTarget3.stBeamParams := stFoilBP;
    fbPF1K0.stTarget3.bValid := TRUE;

    fbPF1K0.stTarget4.fPosition := -53.5;
    fbPF1K0.stTarget4.bUseRawCounts := FALSE;
    fbPF1K0.stTarget4.nRequestAssertionID := 16#3105;
    fbPF1K0.stTarget4.stBeamParams := stFoilBP;
    fbPF1K0.stTarget4.bValid := TRUE;

    fbPF1K0.stTarget5.fPosition := -39.124;
    fbPF1K0.stTarget5.bUseRawCounts := FALSE;
    fbPF1K0.stTarget5.nRequestAssertionID := 16#3106;
    fbPF1K0.stTarget5.stBeamParams := stFoilBP;
    fbPF1K0.stTarget5.bValid := TRUE;

    fbPF1K0(
        fbArbiter := GVL.fbArbiter,
        fbFFHWO := GVL.fbFastFaultOutput1,
        stYStage := Main.M8,
        stZStage := Main.M9);

    END_PROGRAM


PRG_RTDSK0
^^^^^^^^^^

::

    PROGRAM PRG_RTDSK0
    VAR

       {attribute 'TcLinkTo' := '.i_xInsertedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 1^Input;
                                 .i_xRetractedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 2^Input;
                                 .q_xInsert_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 1^Output;
                                 .q_xRetract_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 2^Output
        '}

         {attribute 'pytmc' :=' pv: RTDSK0:MPA:01 '}
        RTDSK0_MPA_01: FB_MPA := (sName := 'RTDSK0:MPA:01');

       {attribute 'TcLinkTo' := '.i_xInsertedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 3^Input;
                                 .i_xRetractedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 4^Input;
                                 .q_xInsert_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 3^Output;
                                 .q_xRetract_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 4^Output
        '}


        {attribute 'pytmc' :=' pv: RTDSK0:MPA:02 '}
        RTDSK0_MPA_02: FB_MPA := (sName := 'RTDSK0:MPA:02');

           {attribute 'TcLinkTo' := '.i_xInsertedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 5^Input;
                                 .i_xRetractedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 6^Input;
                                 .q_xInsert_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 5^Output;
                                 .q_xRetract_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 6^Output
        '}

        {attribute 'pytmc' :=' pv: RTDSK0:MPA:03 '}
        RTDSK0_MPA_03: FB_MPA := (sName := 'RTDSK0:MPA:03');

           {attribute 'TcLinkTo' := '.i_xInsertedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 7^Input;
                                 .i_xRetractedLS := TIIB[RTDSK0-MPA-EL1008]^Channel 8^Input;
                                 .q_xInsert_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 7^Output;
                                 .q_xRetract_DO :=  TIIB[RTDSK0-MPA-EL2008]^Channel 8^Output
        '}
        {attribute 'pytmc' :=' pv: RTDSK0:MPA:04 '}
        RTDSK0_MPA_04: FB_MPA := (sName := 'RTDSK0:MPA:04');



    END_VAR
    //Pneumatic actuators - OTR filters

    RTDSK0_MPA_01(
        ibInsertOK:= TRUE,
        ibRetractOK:= TRUE ,
        ibPMPS_OK:= TRUE ,
        ibOverrideInterlock:= ,
        q_stAct=> ,
        xMPS_OK=> ,
        xDone=> ,
        i_xReset := ,
        io_fbFFHWO := GVL.fbFastFaultOutput1,
    );

    RTDSK0_MPA_02(
        ibInsertOK:= TRUE,
        ibRetractOK:= TRUE ,
        ibPMPS_OK:= TRUE ,
        ibOverrideInterlock:= ,
        q_stAct=> ,
        xMPS_OK=> ,
        xDone=> ,
        i_xReset := ,
        io_fbFFHWO := GVL.fbFastFaultOutput1,
    );

    (*
    Disable MPA_03 and MPA_04, no actuator installed

    RTDSK0_MPA_03(
        ibInsertOK:= TRUE,
        ibRetractOK:= TRUE ,
        ibPMPS_OK:= TRUE ,
        ibOverrideInterlock:= ,
        q_stAct=> ,
        xMPS_OK=> ,
        xDone=> ,
        i_xReset := ,
        io_fbFFHWO := GVL.fbFastFaultOutput1,
    );

    RTDSK0_MPA_04(
        ibInsertOK:= TRUE,
        ibRetractOK:= TRUE ,
        ibPMPS_OK:= TRUE ,
        ibOverrideInterlock:= ,
        q_stAct=> ,
        xMPS_OK=> ,
        xDone=> ,
        i_xReset := ,
        io_fbFFHWO := GVL.fbFastFaultOutput1,
    );
    *)

    END_PROGRAM


PRG_SL1K0_POWER
^^^^^^^^^^^^^^^

::

    PROGRAM PRG_SL1K0_POWER
    VAR
        {attribute 'pytmc' := '
            pv: SL1K0:POWER
            io: io
        '}
        {attribute 'TcLinkTo' := '.RTD_South_1.iRaw := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 1^Value;
                                  .RTD_South_1.bError := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_South_1.bUnderrange := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_South_1.bOverrange := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_South_2.iRaw := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 2^Value;
                                  .RTD_South_2.bError := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_South_2.bUnderrange := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_South_2.bOverrange := TIIB[SL1K0-EL3202-E6]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_TOP_1.iRaw := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 1^Value;
                                  .RTD_TOP_1.bError := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_TOP_1.bUnderrange := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_TOP_1.bOverrange := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_TOP_2.iRaw := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 2^Value;
                                  .RTD_TOP_2.bError := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_TOP_2.bUnderrange := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_TOP_2.bOverrange := TIIB[SL1K0-EL3202-E7]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_North_1.iRaw := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 1^Value;
                                  .RTD_North_1.bError := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_North_1.bUnderrange := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_North_1.bOverrange := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_North_2.iRaw := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 2^Value;
                                  .RTD_North_2.bError := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_North_2.bUnderrange := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_North_2.bOverrange := TIIB[SL1K0-EL3202-E8]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_Bottom_1.iRaw := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 1^Value;
                                  .RTD_Bottom_1.bError := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_Bottom_1.bUnderrange := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_Bottom_1.bOverrange := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_Bottom_2.iRaw := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 2^Value;
                                  .RTD_Bottom_2.bError := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_Bottom_2.bUnderrange := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_Bottom_2.bOverrange := TIIB[SL1K0-EL3202-E9]^RTD Inputs Channel 2^Status^Overrange;
                                  .AptArrayStatus := 'TIIB[PMPS_PRE]^IO Outputs^AptArrayStatus^AptArrayStatus[1];
                                  .AptArrayReq := 'TIIB[PMPS_PRE]^IO Inputs^AptArrayReq^AptArrayReq[1]'}
        fbSL1K0: FB_SLITS_POWER;
    //{attribute 'TcLinkTo' := 'TIIB[PMPS_PRE]^IO Outputs^AptArrayStatus'}
        {attribute 'pytmc' := '
        pv: SL1K0:POWER:GO;
        io: io;
        field: ZNAM False;
        field: ONAM True;
        '}
        bExecuteMotion:BOOL ;
        //GET PMPS Move Ok bit
        // Default True until it is properly linked to PMPS bit
        bMoveOk:BOOL :=TRUE;

        //for testing purposes only. comment-out/delete once done.
        mcPower : ARRAY [1..4] OF MC_POWER;
        bTest:BOOL:=FALSE;

        (*Offsets*)
        (* Absolute encoder value at the HLS + Absolure eoncoder value at the centered beam *)
        rEncoderOffsetTop: REAL := -11; (* 0+(-15)*)
        rEncoderOffsetBottom: REAL := -11.9; (* 0+(-15)*)
        rEncoderOffsetNorth: REAL := -5;(* 0+(-15)*)
        rEncoderOffsetSouth: REAL := -12.9;(* 0+(-15)*)
    END_VAR
    fbSL1K0.bMoveOk := bMoveOk;




    //for testing purposes only. comment-out/delete once done.
    If bTest THEN
        mcPower[1](axis:=Main.M18.Axis, Enable:=TRUE, enable_positive:=Main.M18.bLimitForwardEnable, enable_negative:=Main.M18.bLimitBackwardEnable);
    mcPower[2](axis:=Main.M19.Axis, Enable:=TRUE, enable_positive:=Main.M19.bLimitForwardEnable, enable_negative:=Main.M19.bLimitBackwardEnable);
    mcPower[3](axis:=Main.M20.Axis, Enable:=TRUE, enable_positive:=Main.M20.bLimitForwardEnable, enable_negative:=Main.M20.bLimitBackwardEnable);
    mcPower[4](axis:=Main.M21.Axis, Enable:=TRUE, enable_positive:=Main.M21.bLimitForwardEnable, enable_negative:=Main.M21.bLimitBackwardEnable);

    else

    fbSL1K0.rEncoderOffsetTop := rEncoderOffsetTop;
    fbSL1K0.rEncoderOffsetBottom := rEncoderOffsetBottom;
    fbSL1K0.rEncoderOffsetNorth := rEncoderOffsetNorth;
    fbSL1K0.rEncoderOffsetSouth := rEncoderOffsetSouth;

    fbSL1K0(stTopBlade:=  Main.M19,
            stBottomBlade:= Main.M21,
            stNorthBlade:=  Main.M20,
            stSouthBlade:=  Main.M18,
            bExecuteMotion:=bExecuteMotion,
            io_fbFFHWO := GVL.fbFastFaultOutput1,
            fbArbiter := GVL.fbArbiter);

    fbSL1K0.M_UpdatePMPS(1);

    END_IF

    END_PROGRAM


PRG_SL2K0_POWER
^^^^^^^^^^^^^^^

::

    PROGRAM PRG_SL2K0_POWER
    VAR
        {attribute 'pytmc' := '
            pv: SL2K0:POWER
            io: io
        '}
        {attribute 'TcLinkTo' := '.RTD_South_1.iRaw := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 1^Value;
                                  .RTD_South_1.bError := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_South_1.bUnderrange := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_South_1.bOverrange := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_South_2.iRaw := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 2^Value;
                                  .RTD_South_2.bError := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_South_2.bUnderrange := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_South_2.bOverrange := TIIB[SL2K0-EL3202-E8]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_TOP_1.iRaw := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 1^Value;
                                  .RTD_TOP_1.bError := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_TOP_1.bUnderrange := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_TOP_1.bOverrange := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_TOP_2.iRaw := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 2^Value;
                                  .RTD_TOP_2.bError := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_TOP_2.bUnderrange := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_TOP_2.bOverrange := TIIB[SL2K0-EL3202-E9]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_North_1.iRaw := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Value;
                                  .RTD_North_1.bError := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_North_1.bUnderrange := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_North_1.bOverrange := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_North_2.iRaw := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 2^Value;
                                  .RTD_North_2.bError := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_North_2.bUnderrange := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_North_2.bOverrange := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 2^Status^Overrange;
                                  .RTD_Bottom_1.iRaw := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Value;
                                  .RTD_Bottom_1.bError := TIIB[SL2K0-EL3202-E10]^RTD Inputs Channel 1^Status^Error;
                                  .RTD_Bottom_1.bUnderrange := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 1^Status^Underrange;
                                  .RTD_Bottom_1.bOverrange := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 1^Status^Overrange;
                                  .RTD_Bottom_2.iRaw := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 2^Value;
                                  .RTD_Bottom_2.bError := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 2^Status^Error;
                                  .RTD_Bottom_2.bUnderrange := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 2^Status^Underrange;
                                  .RTD_Bottom_2.bOverrange := TIIB[SL2K0-EL3202-E11]^RTD Inputs Channel 2^Status^Overrange;
                                  .AptArrayStatus := 'TIIB[PMPS_PRE]^IO Outputs^AptArrayStatus^AptArrayStatus[2];
                                  .AptArrayReq := 'TIIB[PMPS_PRE]^IO Inputs^AptArrayReq^AptArrayReq[2]'}
        fbSL2K0: FB_SLITS_POWER;
    //GET PMP Move Ok bit
    // Default True until it is properly linked to PMPS bit
        bMoveOk:BOOL :=TRUE;
        {attribute 'pytmc' := '
        pv: SL2K0:POWER:GO;
        io: io;
        field: ZNAM False;
        field: ONAM True;
        '}
        bExecuteMotion:BOOL ;
        //for testing purposes only. comment-out/delete once done.
        mcPower : ARRAY [1..4] OF MC_POWER;
            (*Offsets*)
        (* Absolute encoder value at the HLS + Absolure eoncoder value at the centered beam *)
        rEncoderOffsetTop: REAL := 15.1;
        rEncoderOffsetBottom: REAL := -12.2;
        rEncoderOffsetNorth: REAL := 15.4;
        rEncoderOffsetSouth: REAL := -13.4;
    END_VAR
    fbSL2K0.bMoveOk := bMoveOk;

    fbSL2K0.rEncoderOffsetTop := rEncoderOffsetTop;
    fbSL2K0.rEncoderOffsetBottom := rEncoderOffsetBottom;
    fbSL2K0.rEncoderOffsetNorth := rEncoderOffsetNorth;
    fbSL2K0.rEncoderOffsetSouth := rEncoderOffsetSouth;

    fbSL2K0(stTopBlade:=  Main.M23,
            stBottomBlade:= Main.M25,
            stNorthBlade:=  Main.M24,
            stSouthBlade:=  Main.M22,
            bExecuteMotion:=bExecuteMotion,
            io_fbFFHWO := GVL.fbFastFaultOutput1,
            fbArbiter := GVL.fbArbiter);

    fbSL2K0.M_UpdatePMPS(2);


    //for testing purposes only. comment-out/delete once done.
    (*mcPower[1](axis:=Main.M22.Axis, Enable:=TRUE, enable_positive:=Main.M22.bLimitForwardEnable, enable_negative:=Main.M22.bLimitBackwardEnable);
    mcPower[2](axis:=Main.M23.Axis, Enable:=TRUE, enable_positive:=Main.M23.bLimitForwardEnable, enable_negative:=Main.M23.bLimitBackwardEnable);
    mcPower[3](axis:=Main.M24.Axis, Enable:=TRUE, enable_positive:=Main.M24.bLimitForwardEnable, enable_negative:=Main.M24.bLimitBackwardEnable);
    mcPower[4](axis:=Main.M25.Axis, Enable:=TRUE, enable_positive:=Main.M25.bLimitForwardEnable, enable_negative:=Main.M25.bLimitBackwardEnable);*)

    END_PROGRAM


PRG_ST1K4_TEST
^^^^^^^^^^^^^^

::

    PROGRAM PRG_ST1K4_TEST
    VAR
        fbMotion1: FB_MotionStage;
    END_VAR
    // M33, Axis 33
    Main.M33.nEnableMode	:= ENUM_StageEnableMode.DURING_MOTION;
    Main.M33.bHardwareEnable:= TRUE;
    Main.M33.bPowerSelf := TRUE;
    Main.M33.nBrakeMode := ENUM_StageBrakeMode.IF_ENABLED;
    fbMotion1(stMotionStage:=Main.M14);

    END_PROGRAM

